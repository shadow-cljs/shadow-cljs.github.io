= Shadow CLJS User's Guide
:author: Thomas Heller and Tony Kay
:revdate: Jan 10, 2018
:revnumber: 1.0
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: assets/img
:scriptsdir: js
:imagesoutdir: assets/img

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= Prologue

This is a work in progress. It has not been proofread and may contain errors. If you find an error, please
submit a PR to fix it, or an issue with details of the problem.

= Why shadow-cljs?

The shadow-cljs compiler provides everything you need to compile your
ClojureScript code with a focus on simplicity and ease of use. It augments
the official Clojurescript compiler with a number of additional
features and enhancements:

* More reliable NPM integration
** More likely your favorite js library will work
* Less configuration
* Deterministic build order
* No need for build-specific source directories
* Better externs checker
* Better warning tracker
* Easier use with js projects
* Includes hot code reload
* Smart integration with CLJS testing for the browser and CI
* The built-in development server aggressively fixes browser caching issues

= Basic Configuration

== Initial Set-up

== Installing the Tools

You will need:

* `npm` or `yarn`.
* A `package.json` file describing your development dependencies.
* (optional) A global install of the `shadow-cljs` CLI.

.NPM
```bash
$ npm install --save-dev shadow-cljs
$ npm install -g shadow-cljs
```

.Yarn
```bash
$ yarn add --dev shadow-cljs
$ yarn global add shadow-cljs
```

== NPM Modules

It is likely that you're using libraries (directly or transitively) that in turn use low-level Javascript code. For
example `cljsjs.react`. It is fine to have these in your dependencies, but you must ensure that the real underlying
NPM version of those is installed.

This is relatively easy to manage. If you're using Leiningen or Cursive you can easily look at the deps tree
and find the cljsjs package, and make sure they're also in your `package.json` file as NPM dev deps.

```bash
$ lein deps :tree
```

If you're using `shadow-cljs` alone, then you can generate a POM for Maven and get the same effect:

```bash
$ shadow-cljs pom
$ mvn dependency:tree
```

Alternatively you could simply try to build the project and respond to missing dependency errors
with additions to your `package.json` file and an `npm install`.

Read more about using arbitrary npm modules in you Clojurescript in a <<UsingNPMModules,later chapter>>.

== Core Options

The first options you need to set are the location of your source folder(s) and your dependencies.
All settings go in `shadow-cljs.edn` in the top-level directory of your project. In this book
any abiguous reference to "configuration file" should be assumed to mean this file:

.The main configuration file: `shadow-cljs.edn`
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 ...
```

Notice that the source path is *only* specified once in the entire configuration. The system will
use namespace dependency graphs to determine what code is needed in the final output of any given
build.

== Builds

You will also need a `:builds` section, which is a map keyed by "build ID":

.A configuration file with builds.
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 :builds
   {:app      {:target     :browser
               :output-dir "resources/public/js"
               :asset-path "/js"

               :modules    {:main {:entries [starter.browser]}}}
     :tests   {:target :karma
               ...}})
```

=== Output Settings

[Horizontal]
`:target`:: The compile target. Can be one of `:browser`, `:bootstrap`, `:browser-test`, `:karma`, `:node-library`,
`:node-script`, or `:npm-module`.
`:output-dir`:: The directory to use for all output. Your entry point javascript file will appear here.
`:asset-path`:: The relative path from *web server's root* to the resources in `:output-dir`. For
example if your web server will serve `resources/public` and your `output-dir` is `resources/public/js`
then your asset-path should be `/js`.

WARNING: Each build requires its own :output-dir, you may not put multiple builds into the same directory.
This directory should also be exclusively owned by the build. There should be no other files in there.
While `shadow-cljs` won't delete anything it is safer to leave it alone. Compilation
creates many more files than just the main entry point javascript file during development:
source maps, original sources, and generated sources.

The supported targets are:

[Horizontal]
`:browser`:: Output code suitable for running in a web browser.
`:bootstrap`:: Output code suitable for running in bootstrapped cljs environment.
`:browser-test`:: Scan for tests to determine required files, and output tests suitable for running in the browser.
`:karma`:: Scan for tests to determine required files, and output karma-runner compatible tests. See http://karma-runner.github.io/2.0/index.html[Karma].
`:node-library`:: Output code suitable for use as a node library.
`:node-script`:: Output code suitable for use as a node script.
`:npm-module`:: Output code suitable for use as an NPM module.

The details of these targets are be discussed more in later sections. (TODO)

=== Modules

All projects will have one or more modules. If you're doing code splitting, then you will have more than one. If you're
not code splitting, then you'll have one. See the <<Modules, the modules chapter>> for more information on code splitting.

For now, know that a module definition need the following minimum things: A name (as a keyword) and one or more
namespaces of the entry point(s) for code execution:

```
{...
 :builds {
   :app  {...
          :modules {:main {:entries [my.app.main]}}}}}
```

shadow-cljs will follow the dependency graph from this root set of code entry points to find everything needed
to actually run.

= Development

As a developer most of your time is spent in development mode. You're probably familiar with tools like `figwheel`,
`boot-reload`, and `devtools`. It's almost certain that you want one or more of these in your builds.

== Preloads

Preloads are used to force certain namespaces into the front of your generated Javascript. This is
generally used to inject tools and instrumutation before the application actually loads and runs. The
preloads option is simply a list of namespaces in the `:devtools`/`:preloads` section of
`shadow-cljs-edn`:

```
{:dependencies [...]
 :builds
        {:app      {:target     :browser
                    :output-dir "resources/public/js"
                    :asset-path "/js"
                    :modules    { ... }
                    :devtools   {:preloads   [fulcro.inspect.preload]
                                 ... }}}}
```

=== Chrome Devtools Preloads

See <<Chrome Devtools>> if you'd like to include preloads for Chrome Devtools.

== Hot Code Reload

The React and Clojurescript ecosystems combine to make this kind of thing super useful. The `shadow-cljs`
system includes everything you need to do your hot code reload, without needing to resort to external tools.

In order to use it you simply run:

```
shadow-cljs watch build-id
```

However, you probably need a few more options in order for it to work
well in your project. In particular you probably need one or more
of the following:

* A way to serve files/resources
* Hooks to initialize and start your application
* Possibly a hook to stop you application before a reload

== HTTP Server

The `:devtools` section of the configuration supports
options for configuring an optional dev-time HTTP server for a build. The server supports the following
options:

[Horizontal]
`:http-root`:: The disk path from which to serve root filesystem requests. If not supplied,
no disk files are served.
`:http-port`:: The port to serve from.
`:http-host`:: The hostname to listen on. Defaults to localhost).
`:http-resource-root`:: A sequence of paths relative to classpath from which resources can be scanned.
If not supplied, no resources are served.
`:http-handler`:: A namespace (as a symbol). A `(fn [req] resp)` that is used
if a resource is not found for the given request. Defaults to a not-found handler.

=== Lifecycle Hooks

The build configuration supports hooks that allow you to run functions just before hot code reload
brings in updated code, and just after. These are useful for stopping/starting things that would otherwise
close over old code. The options go in the `:devtools` section of the config and are:

[Horizontal]
`:before-load`:: A symbol (with namespace) of a function to run just before refreshing
files that have been recompiled.  This function *must* by synchronous in nature.
`:before-load-async`:: A symbol (with namespace) of a function `(fn [done] )` to run just before refreshing. This function
can do async processing, but *must* call `(done)` to indicate it is complete.
`:after-load`:: A symbol (with namespace) of a function to run after hot code reload is complete.

.A sample of lifecycle hooks.
```
{...
 :builds {
   :app  {...
          :devtools        {:after-load   app.ui/start-workers!
                            :before-load  app.workers/stop-workers!
                             ...}}}}
```

== REPL

You can use the command-line utility to connect to a REPL simply by using a running build ID:

.Browser REPL
```
shadow-cljs cljs-repl app
```

.Node REPL
```
shadow-cljs node-repl
```

== nREPL

When an active dev build is running there will be an nREPL. If you look at the startup message you'll see
the port of nREPL, and the port will also be stored in `target/shadow-cljs/nrepl.port`:

```bash
$ shadow-cljs watch dev
shadow-cljs - HTTP server for ":app" available at http://localhost:8020
shadow-cljs - server running at http://0.0.0.0:9630
shadow-cljs - nrepl running at /0.0.0.0:9462
shadow-cljs - watching build :app
[:app] Configuring build.
[:app] Compiling ...
```

You can configure the port and additional middleware with `shadow-cljs.edn`:

```
{...
 :nrepl {:port 9000
         :middleware []} ; list of namespace-qualified symbols
}
```

== Cursive

If you're a Cursive user then you currently need at least a dummy `project.clj` file. You may also wish to
read the

```
(defproject your/project "0.0.0"
  :dependencies
  [[thheller/shadow-cljs "1.0.20170629"]]

  :source-paths
  ["src"])
```

This will allow Cursive to detect the proper source paths for the project.

If you want the full Cursive experience including proper code navigation then you want to use full
<<Leiningen, Leiningen integration>>.

=== Cursive REPL Integration

An nREPL is created by `shadow-cljs` when it is in development mode. You can connect to it to get
REPL integration using a Clojure Remote REPL run configuration.

By default the network port number is random, but that will be a major pain. You have
two choices:

. Configure the nREPL port
. Use a symlink to get the port into the standard location.

Option 1 is nice because it doesn't require any filesystem interactions:

.NREPL in shadow-cljs.edn
```
{:nrepl {:port 9000}}
```

Option 2 is simple, but involves using the standard nREPL port file, which you may need for other
network REPLs like your server. The port for the `shadow-cljs` REPL is written out to
`target/shadow-cljs/nrepl.port`, so simply symbolically link this file to the standard
`~/.nrepl-port`:

.Using a symbolic link for REPL port
```
ln -sv target/shadow-cljs/nrepl.port .nrepl-port
```

Once you've chosen your option for tracking the port, you can add a run configuration via
`Run -> Edit Configurations...`:

.Clicking on the `+` icon will add a new run configuration.
image::cursive-repl-1.png[]

.Choose a Clojure Remote REPL
image::cursive-repl-2.png[]

In the last step either type in the port you've set in your config, or choose to use the
standard nrepl port:

.If you're using `.nrepl-port`, then configure as shown. If you configured the port number in `shadow-cljs.edn` then use `localhost` and the configured port number.
image::cursive-repl-3.png[]

== CIDER

CIDER support requires the simple combination of having the `cider-nrepl` dependency on your
classpath and configuring nREPL. The entries to `shadow-cljs.edn` are simply:

```
{:dependencies [[cider/cider-nrepl "0.16.0-SNAPSHOT"]]
 :nrepl {:port 8202}

 ...
}
```

then invoke the `cider-connect` function from emacs.

When you connect to the nREPL it will start out in CLJ mode. If you select a running build it should
switch the nREPL session to CLJS.

Internally, it does this either by calling a fake piggieback function or the "official" API:

```
(cemerick.piggieback/cljs-repl :id-of-build)
;; or
(shadow.cljs.devtools.api/nrepl-select :id-of-build)
```

Once connected you should be able to eval code using `C-c C-c` (eval a block), `C-x C-e` (eval sexp),
or `C-c C-k` (eval buffer).

If you see an error like "`cider-load-buffer' needs a ClojureScript REPL", you need to hit
enter once in the repl buffer. Emacs should then recognize that you have a cljs repl buffer and
evals should start working.

NOTE: `shadow-cljs` will automatically add the required `cider-nrepl` middleware when it finds `cider.nrepl`
on your classpath, i.e. in your dependencies.


== Leiningen Integration [[Leiningen]]

If you'd like to use Leiningen for your build system (particularly if you use Cursive) then there is a simple option
in your `shadow-cljs.edn` file that causes it to derive `:source-paths` and `:dependencies` from `project.clj`:

```
{:lein true
 ; source-paths and dependencies are now ignored in this file, and come from project.clj instead
 :builds { ... }
```

Remember that you don't need to split up your source paths for `shadow-cljs`. It can derive which files are needed
from the namespace dependency graph and module settings.

=== Running Tasks Directly From Leiningen

shadow-cljs is built as a Clojure library, which means you can use it directly from lein without
installing the CLI command via npm.

You only need to add `shadow-cljs` to your `project.clj` `:dependencies`.

[link=https://clojars.org/thheller/shadow-cljs]
image::https://camo.githubusercontent.com/f91298f67b2b1c7a75124738f669be1f6928e976/68747470733a2f2f696d672e736869656c64732e696f2f636c6f6a6172732f762f746868656c6c65722f736861646f772d636c6a732e737667[]

The classpath of your project will be used to search for .cljs files. There is no
other dedicated configuration for shadow-cljs in project.clj. If you have a dedicated
directory for your .cljs files add that to your top-level `:source-paths`.

NOTE: This works even if you don't enable full integration in the `shadow-cljs.edn` configuration
file.

Some sample commands are listed below:

.Listing Options
```bash
lein run -m shadow.cljs.devtools.cli help
```

.Start a dev mode build with a REPL and live-reload
```bash
$ lein run -m shadow.cljs.devtools.cli watch build-id
```

.Just compile :dev mode once, no REPL or live-reload:
```bash
$ lein run -m shadow.cljs.devtools.cli compile build-id
```

.Create a :release mode optimized build:
```bash
lein run -m shadow.cljs.devtools.cli release build-id
```

=== Full Integration

The `shadow-cljs` command-line utility can also use `lein` to run your commands. You can enable this
by adding a :lein entry to your shadow-cljs.edn config.

{:lein {:profile "+cljs"}
 :builds {...}}

This will execute all shadow-cljs commands via lein instead of launching its own JVM.

```
lein with-profile +cljs run -m shadow.cljs.devtools.cli ...
```

The `:profile` is optional, `:lein true` or `:lein {}` is enough to enable lein support.
When this mode is active the
`:source-paths and :dependencies inside shadow-cljs.edn will be ignored.


== Chrome Devtools

The shadow-cljs tool system comes with some basic data formatters that
aid in debugging when using Chrome. You don't have to do anything to get these.

If you'd like to use the popular https://github.com/binaryage/cljs-devtools[binaryage/cljs-devtools],
shadow-cljs makes this easy by automatically including the preload for you whenever
`binaryage.devtools.preloads` exists on your classpath.

Additional development tools, such as `fulcro.inspect`, can easily be added by
manually specifying the preload:

```
{...
 :builds {
   :cards  {:target           :browser
            ...
            :devtools         {:preloads   [fulcro.inspect.preload]
                               ...}}}}
```

= Release Mode

Development mode always outputs individual files for each namespace so that they can be hot loaded
in isolation. When you're ready to deploy code to a real server you want to run the Closure Compiler
on it to generate a single minified result for each <<Modules, module>>.

.Generating Minified Output
```
$ shadow-cljs release build-id
```

== Optimizations

You can choose the optimization level using the `:compiler-options` section of the configuration:

```
{...
 :build
   {:build-id
     {...
      :compiler-options {:optimizations :whitespace}}}}
```

See the https://developers.google.com/closure/compiler/docs/compilation_levels[the Closure compiler's documentation]
for more information on available optimization levels.

== Release-Specific vs. Development Configuration

If you wish to have separate configuration values in a build when running a release build then you
can override settings by including a `:dev` and/or `:release` section in the build section:

```
{:source-paths ["src"]
 :dependencies []
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   :modules {:base {:entries [my.app.core]}}

   ;; Here is some dev-specific config
   :dev {:compiler-options {:devcards true}}

   ;; Here is some production config
   :release {:compiler-options {:optimizations :whitespace}}}}}
```

= Modules and Code Splitting [[Modules]]

You've already seen how to configure your main module. Adding additional modules requires a little
bit of care, but the technical details are simple:

. Ensure you don't require things you don't use in any namespace.
. Put the top-level namespace(s) for each module into a module config.
. Choose you dynamic loading API

== Using shadow-cljs's built-in Loader Support

== Using the Standard Clojurescript API

The generated code is capable of using the standard Clojurescript `cljs.loader` API. See the
https://clojurescript.org/news/2017-07-10-code-splitting[documentation] on the Clojurescript website for instructions.

= Using NPM Modules

= Hacking

== Patching Libraries

The shadow-cljs compiler ensure that things on your source paths are
compiled last. Things from JAR files go first. This means that
you can copy a source file from a library, patch it, and include it
in your own source directory. This is a convenient way to test out
fixes (even to `shadow-cljs` itself!) without having to clone
that project and understand its setup, build, etc.

