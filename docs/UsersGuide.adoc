= Shadow CLJS User's Guide
:author: Thomas Heller and Tony Kay
:revdate: Jan 10, 2018
:revnumber: 1.0
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: assets/img
:scriptsdir: js
:imagesoutdir: assets/img

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= Introduction

This is a work in progress. It has not been proofread and may contain errors. If you find an error, please
submit a PR to fix it, or an issue with details of the problem.

== Why shadow-cljs?

The shadow-cljs compiler provides everything you need to compile your
ClojureScript code with a focus on simplicity and ease of use. It augments
the official Clojurescript compiler with a number of additional
features and enhancements:

* More reliable NPM integration
** More likely your favorite js library will work
* Less configuration
* Deterministic build order
* No need for build-specific source directories
* Better externs checker
* Better warning tracker
* Easier use with js projects
* Includes hot code reload
* Smart integration with CLJS testing for the browser and CI
* The built-in development server aggressively fixes browser caching issues

== Installing the Tools

You will need:

* `npm` or `yarn`.
* A `package.json` file describing your development dependencies.
* (optional) A global install of the `shadow-cljs` CLI.

.NPM
```bash
$ npm install --save-dev shadow-cljs
$ npm install -g shadow-cljs
```

.Yarn
```bash
$ yarn add --dev shadow-cljs
$ yarn global add shadow-cljs
```

== Basic Configuration

=== Core Options

The first options you need to set are the location of your source folder(s) and your dependencies.
All settings go in `shadow-cljs.edn` in the top-level directory of your project. In this book
any abiguous reference to "configuration file" should be assumed to mean this file:

.The main configuration file: `shadow-cljs.edn`
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 ...
```

Notice that the source path is *only* specified once in the entire configuration. The system will
use namespace dependency graphs to determine what code is needed in the final output of any given
build.

=== Builds

You will also need a `:builds` section. Builds can be a vector of builds that *have* IDs, or a
map of builds *keyed* by build ID:

.A configuration file with a build map.
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 :builds
   {:app      {:target     :browser
               ... target-specific options ...}
     :tests   {:target :karma
               ... target-specific options ...}}}
```

.A configuration with a vector of builds
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]

 :builds [{:id :app
           :target     :browser
           ... target-specific options ...}
          {:id :tests
           :target :karma
           ... target-specific options ...}]}
```

Each build describes artifacts that the compiler will build. The build target is an
extensible feature of `shadow-cljs`, and the compiler comes with quite a few of them already.

Here are some of them:

[Horizontal]
`:browser`:: Output code suitable for running in a web browser.
`:bootstrap`:: Output code suitable for running in bootstrapped cljs environment.
`:browser-test`:: Scan for tests to determine required files, and output tests suitable for running in the browser.
`:karma`:: Scan for tests to determine required files, and output karma-runner compatible tests. See http://karma-runner.github.io/2.0/index.html[Karma].
`:node-library`:: Output code suitable for use as a node library.
`:node-script`:: Output code suitable for use as a node script.
`:npm-module`:: Output code suitable for use as an NPM module.

Each target is covered in more detail in its own chapter since the remaining build options vary on
the target you select.

=== More Common Options

This section is for other options that are in-common with all builds.

= Targeting the Browser

There are a few targets that target web browsers in various ways, and since the targets are pluggable
it is easy to imagine additional targets for specific scenarios. This chapter concentrates on the
most commonly-user `:browser` target, but many of the configuration options may apply to browser-related
targets.

A basic browser configuration looks like this:

```
{:dependencies [...]
 :source-paths [...]

 :builds [{:id :app
           :target :browser

           :output-dir "public/assets/app/js"
           :asset-path "/assets/app/js"

           :modules {:main {:entries [my.app]}}}]}
```

We've already covered the basic settings in the <<Introduction, introduction>>. Now, we'll concentrate
on the browser-specific settings.

== Output Settings

The browser target outputs a lot of files, and a directory is needed for them all. You'll need to serve
these assets with some kind of server, and the Javascript loading code needs to know the server-centric
path to these assets. The options you need to specify are:

[Horizontal]
`:output-dir`:: The directory to use for all output. Your entry point javascript file will appear here.
`:asset-path`:: The relative path from *web server's root* to the resources in `:output-dir`. For
example if your web server will serve `resources/public` and your `output-dir` is `resources/public/js`
then your asset-path should be `/js`.

WARNING: Each build requires its own :output-dir, you may not put multiple builds into the same directory.
This directory should also be exclusively owned by the build. There should be no other files in there.
While `shadow-cljs` won't delete anything it is safer to leave it alone. Compilation
creates many more files than just the main entry point javascript file during development:
source maps, original sources, and generated sources.

You are not required to use an absolute asset path, but an absolute path is highly recommended.

== Cljsjs and NPM Modules

It is likely that you're using libraries (directly or transitively) that in turn use low-level Javascript code. For
example `cljsjs.react`. It is fine to have these in your dependencies, but you must ensure that the real underlying
NPM version of those is installed.

This is relatively easy to manage. If you're using Leiningen or Cursive you can easily look at the deps tree
and find the cljsjs package, and make sure they're also in your `package.json` file as NPM dev deps.

```bash
$ lein deps :tree
```

If you're using `shadow-cljs` alone, then you can generate a POM for Maven and get the same effect:

```bash
$ shadow-cljs pom
$ mvn dependency:tree
```

Alternatively you could simply try to build the project and respond to missing dependency errors
with additions to your `package.json` file and an `npm install`.

Read more about using arbitrary npm modules in you Clojurescript in a <<UsingNPMModules,later chapter>>.

== Modules

All projects will have one or more modules. If you're doing code splitting, then you will have more than one. If you're
not code splitting, then you'll have one. See the <<Modules, the modules chapter>> for more information on code splitting.

For now, know that a module definition need the following minimum things: A name (as a keyword) and one or more
namespaces of the entry point(s) for code execution:

```
{...
 :builds {
   :app  {...
          :modules {:main {:entries [my.app.main]}}}}}
```

shadow-cljs will follow the dependency graph from this root set of code entry points to find everything needed
to actually run.

== Preloads

As a developer most of your time is spent in development mode. You're probably familiar with tools like `figwheel`,
`boot-reload`, and `devtools`. It's almost certain that you want one or more of these in your builds.

Preloads are used to force certain namespaces into the front of your generated Javascript. This is
generally used to inject tools and instrumutation before the application actually loads and runs. The
preloads option is simply a list of namespaces in the `:devtools`/`:preloads` section of
`shadow-cljs-edn`:

```
{:dependencies [...]
 :builds
        {:app      {:target     :browser
                    :output-dir "resources/public/js"
                    :asset-path "/js"
                    :modules    { ... }
                    :devtools   {:preloads   [fulcro.inspect.preload]
                                 ... }}}}
```

NOTE: Since version 2.0.130 shadow-cljs automatically adds "binaryage/devtools" to the preloads in
`watch` and `compile` if they are on the classpath. All you need to do is make sure it is in your
`dependencies` list.

== Hot Code Reload

The React and Clojurescript ecosystems combine to make this kind of thing super useful. The `shadow-cljs`
system includes everything you need to do your hot code reload, without needing to resort to external tools.

In order to use it you simply run:

```
shadow-cljs watch build-id
```

However, you probably need a few more options in order for it to work
well in your project. In particular you probably need one or more
of the following:

* A way to serve files/resources
* Hooks to initialize and start your application
* Possibly a hook to stop you application before a reload

== HTTP Server

The `:devtools` section of the configuration supports
options for configuring an optional dev-time HTTP server for a build. The server supports the following
options:

[Horizontal]
`:http-root`:: The disk path from which to serve root filesystem requests. If not supplied,
no disk files are served.
`:http-port`:: The port to serve from.
`:http-host`:: The hostname to listen on. Defaults to localhost).
`:http-resource-root`:: A sequence of paths relative to classpath from which resources can be scanned.
If not supplied, no resources are served.
`:http-handler`:: A namespace (as a symbol). A `(fn [req] resp)` that is used
if a resource is not found for the given request. Defaults to a not-found handler.

== Lifecycle Hooks

The build configuration supports hooks that allow you to run functions just before hot code reload
brings in updated code, and just after. These are useful for stopping/starting things that would otherwise
close over old code. The options go in the `:devtools` section of the config and are:

[Horizontal]
`:before-load`:: A symbol (with namespace) of a function to run just before refreshing
files that have been recompiled.  This function *must* by synchronous in nature.
`:before-load-async`:: A symbol (with namespace) of a function `(fn [done] )` to run just before refreshing. This function
can do async processing, but *must* call `(done)` to indicate it is complete.
`:after-load`:: A symbol (with namespace) of a function to run after hot code reload is complete.

.A sample of lifecycle hooks.
```
{...
 :builds {
   :app  {...
          :devtools        {:after-load   app.ui/start-workers!
                            :before-load  app.workers/stop-workers!
                             ...}}}}
```

== Editor/IDE/REPL Setup

=== REPL

You can use the command-line utility to connect to a REPL simply by using a running build ID:

.Browser REPL
```
shadow-cljs cljs-repl app
```

.Node REPL
```
shadow-cljs node-repl
```

=== nREPL

When an active dev build is running there will be an nREPL. If you look at the startup message you'll see
the port of nREPL, and the port will also be stored in `target/shadow-cljs/nrepl.port`:

```bash
$ shadow-cljs watch dev
shadow-cljs - HTTP server for ":app" available at http://localhost:8020
shadow-cljs - server running at http://0.0.0.0:9630
shadow-cljs - nrepl running at /0.0.0.0:9462
shadow-cljs - watching build :app
[:app] Configuring build.
[:app] Compiling ...
```

You can configure the port and additional middleware with `shadow-cljs.edn`:

```
{...
 :nrepl {:port 9000
         :middleware []} ; list of namespace-qualified symbols
}
```

=== Cursive

If you're a Cursive user then you currently need at least a dummy `project.clj` file. You may also wish to
read the

```
(defproject your/project "0.0.0"
  :dependencies
  [[thheller/shadow-cljs "1.0.20170629"]]

  :source-paths
  ["src"])
```

This will allow Cursive to detect the proper source paths for the project.

If you want the full Cursive experience including proper code navigation then you want to use full
<<Leiningen, Leiningen integration>>.

==== Cursive REPL Integration

An nREPL is created by `shadow-cljs` when it is in development mode. You can connect to it to get
REPL integration using a Clojure Remote REPL run configuration.

By default the network port number is random, but that will be a major pain. You have
two choices:

. Configure the nREPL port
. Use a symlink to get the port into the standard location.

Option 1 is nice because it doesn't require any filesystem interactions:

.NREPL in shadow-cljs.edn
```
{:nrepl {:port 9000}}
```

Option 2 is simple, but involves using the standard nREPL port file, which you may need for other
network REPLs like your server. The port for the `shadow-cljs` REPL is written out to
`target/shadow-cljs/nrepl.port`, so simply symbolically link this file to the standard
`~/.nrepl-port`:

.Using a symbolic link for REPL port
```
ln -sv target/shadow-cljs/nrepl.port .nrepl-port
```

Once you've chosen your option for tracking the port, you can add a run configuration via
`Run -> Edit Configurations...`:

.Clicking on the `+` icon will add a new run configuration.
image::cursive-repl-1.png[]

.Choose a Clojure Remote REPL
image::cursive-repl-2.png[]

In the last step either type in the port you've set in your config, or choose to use the
standard nrepl port:

.If you're using `.nrepl-port`, then configure as shown. If you configured the port number in `shadow-cljs.edn` then use `localhost` and the configured port number.
image::cursive-repl-3.png[]

=== CIDER

CIDER support requires the simple combination of having the `cider-nrepl` dependency on your
classpath and configuring nREPL. The entries to `shadow-cljs.edn` are simply:

```
{:dependencies [[cider/cider-nrepl "0.16.0-SNAPSHOT"]]
 :nrepl {:port 8202}

 ...
}
```

then invoke the `cider-connect` function from emacs.

When you connect to the nREPL it will start out in CLJ mode. If you select a running build it should
switch the nREPL session to CLJS.

Internally, it does this either by calling a fake piggieback function or the "official" API:

```
(cemerick.piggieback/cljs-repl :id-of-build)
;; or
(shadow.cljs.devtools.api/nrepl-select :id-of-build)
```

Once connected you should be able to eval code using `C-c C-c` (eval a block), `C-x C-e` (eval sexp),
or `C-c C-k` (eval buffer).

If you see an error like "`cider-load-buffer' needs a ClojureScript REPL", you need to hit
enter once in the repl buffer. Emacs should then recognize that you have a cljs repl buffer and
evals should start working.

NOTE: `shadow-cljs` will automatically add the required `cider-nrepl` middleware when it finds `cider.nrepl`
on your classpath, i.e. in your dependencies.


== Build Tool Integration

=== Leiningen Integration [[Leiningen]]

If you'd like to use Leiningen for your build system (particularly if you use Cursive) then there is a simple option
in your `shadow-cljs.edn` file that causes it to derive `:source-paths` and `:dependencies` from `project.clj`:

```
{:lein true
 ; source-paths and dependencies are now ignored in this file, and come from project.clj instead
 :builds { ... }
```

Remember that you don't need to split up your source paths for `shadow-cljs`. It can derive which files are needed
from the namespace dependency graph and module settings.

==== Running Tasks Directly From Leiningen

shadow-cljs is built as a Clojure library, which means you can use it directly from lein without
installing the CLI command via npm.

You only need to add `shadow-cljs` to your `project.clj` `:dependencies`.

[link=https://clojars.org/thheller/shadow-cljs]
image::https://camo.githubusercontent.com/f91298f67b2b1c7a75124738f669be1f6928e976/68747470733a2f2f696d672e736869656c64732e696f2f636c6f6a6172732f762f746868656c6c65722f736861646f772d636c6a732e737667[]

The classpath of your project will be used to search for .cljs files. There is no
other dedicated configuration for shadow-cljs in project.clj. If you have a dedicated
directory for your .cljs files add that to your top-level `:source-paths`.

NOTE: This works even if you don't enable full integration in the `shadow-cljs.edn` configuration
file.

Some sample commands are listed below:

.Listing Options
```bash
lein run -m shadow.cljs.devtools.cli help
```

.Start a dev mode build with a REPL and live-reload
```bash
$ lein run -m shadow.cljs.devtools.cli watch build-id
```

.Just compile :dev mode once, no REPL or live-reload:
```bash
$ lein run -m shadow.cljs.devtools.cli compile build-id
```

.Create a :release mode optimized build:
```bash
lein run -m shadow.cljs.devtools.cli release build-id
```

==== Full Integration

The `shadow-cljs` command-line utility can also use `lein` to run your commands. You can enable this
by adding a :lein entry to your shadow-cljs.edn config.

{:lein {:profile "+cljs"}
 :builds {...}}

This will execute all shadow-cljs commands via lein instead of launching its own JVM.

```
lein with-profile +cljs run -m shadow.cljs.devtools.cli ...
```

The `:profile` is optional, `:lein true` or `:lein {}` is enough to enable lein support.
When this mode is active the
`:source-paths and :dependencies inside shadow-cljs.edn will be ignored.

=== Boot

The authors have little Boot experience, so this chapter is in need of contributions. We understand
that Boot allows you to build your tool chain out of functions. Since `shadow-cljs` is a normal
JVM library with functions that you can call to invoke tasks.

Here are some of the central functions that seem useful:

// Thomas: care to opine?

== Release Mode

Development mode always outputs individual files for each namespace so that they can be hot loaded
in isolation. When you're ready to deploy code to a real server you want to run the Closure Compiler
on it to generate a single minified result for each <<Modules, module>>.

.Generating Minified Output
```
$ shadow-cljs release build-id
```

=== Optimizations

You can choose the optimization level using the `:compiler-options` section of the configuration:

```
{...
 :build
   {:build-id
     {...
      :compiler-options {:optimizations :whitespace}}}}
```

See the https://developers.google.com/closure/compiler/docs/compilation_levels[the Closure compiler's documentation]
for more information on available optimization levels.

=== Release-Specific vs. Development Configuration

If you wish to have separate configuration values in a build when running a release build then you
can override settings by including a `:dev` and/or `:release` section in the build section:

```
{:source-paths ["src"]
 :dependencies []
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   :modules {:base {:entries [my.app.core]}}

   ;; Here is some dev-specific config
   :dev {:compiler-options {:devcards true}}

   ;; Here is some production config
   :release {:compiler-options {:optimizations :whitespace}}}}}
```

== Modules and Code Splitting [[Modules]]

You've already seen how to configure your main module. Adding additional modules requires a little
bit of care, but the technical details are simple:

. Ensure you don't require things you don't use in any namespace.
. Put the top-level namespace(s) for each module into a module config.
. Choose you dynamic loading API

[horizontal]
`:entries`:: The namespaces that serve as the root nodes of the dependency graph for the output code of this module.
`:depends-on`:: The names of other modules that must be loaded in order for this one to have everything it needs.
`:prepend`:: String content that will be prepended to the js output. Useful for comments, copyright notice, etc.
`:append`:: String content that will be appended to the js output. Useful for comments, copyright notice, etc.
`:prepend-js`:: A string to prepend to the module output containing valid javascript that will be run through Closure optimizer.
`:append-js`:: A string to append to the module output containing valid javascript that will be run through Closure optimizer.

The `modules` section of the config is always a map keyed by module ID. The module ID is also used
to generate the Javascript filename. This is so the module loading code can easily find the correct file
without additional configuration.

=== Using shadow-cljs's built-in Loader Support

=== Using the Standard Clojurescript API

The generated code is capable of using the standard Clojurescript `cljs.loader` API. See the
https://clojurescript.org/news/2017-07-10-code-splitting[documentation] on the Clojurescript website for instructions.

== Using NPM Modules [[UsingNPMModules]]




== Hacking

=== Patching Libraries

The shadow-cljs compiler ensure that things on your source paths are
compiled last. Things from JAR files go first. This means that
you can copy a source file from a library, patch it, and include it
in your own source directory. This is a convenient way to test out
fixes (even to `shadow-cljs` itself!) without having to clone
that project and understand its setup, build, etc.

= Targeting Node

= Other Targets

